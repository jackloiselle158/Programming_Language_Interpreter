/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   TLCons    ********************/

TopLevel make_TLCons(FunDecl p1, TopLevel p2)
{
    TopLevel tmp = (TopLevel) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TLCons!\n");
        exit(1);
    }
    tmp->kind = is_TLCons;
    tmp->u.tLCons_.fundecl_ = p1;
    tmp->u.tLCons_.toplevel_ = p2;
    return tmp;
}

/********************   TLNil    ********************/

TopLevel make_TLNil()
{
    TopLevel tmp = (TopLevel) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating TLNil!\n");
        exit(1);
    }
    tmp->kind = is_TLNil;
    return tmp;
}

/********************   EVar    ********************/

Expr make_EVar(Ident p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EVar!\n");
        exit(1);
    }
    tmp->kind = is_EVar;
    tmp->u.eVar_.ident_ = p1;
    return tmp;
}

/********************   ETrue    ********************/

Expr make_ETrue()
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ETrue!\n");
        exit(1);
    }
    tmp->kind = is_ETrue;
    return tmp;
}

/********************   EFalse    ********************/

Expr make_EFalse()
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EFalse!\n");
        exit(1);
    }
    tmp->kind = is_EFalse;
    return tmp;
}

/********************   EInt    ********************/

Expr make_EInt(Integer p1)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EInt!\n");
        exit(1);
    }
    tmp->kind = is_EInt;
    tmp->u.eInt_.integer_ = p1;
    return tmp;
}

/********************   EBinOp    ********************/

Expr make_EBinOp(Expr p1, Binop p2, Expr p3)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EBinOp!\n");
        exit(1);
    }
    tmp->kind = is_EBinOp;
    tmp->u.eBinOp_.expr_1 = p1;
    tmp->u.eBinOp_.binop_ = p2;
    tmp->u.eBinOp_.expr_2 = p3;
    return tmp;
}

/********************   EFnCall    ********************/

Expr make_EFnCall(Ident p1, FArgs p2)
{
    Expr tmp = (Expr) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EFnCall!\n");
        exit(1);
    }
    tmp->kind = is_EFnCall;
    tmp->u.eFnCall_.ident_ = p1;
    tmp->u.eFnCall_.fargs_ = p2;
    return tmp;
}

/********************   Add    ********************/

Binop make_Add()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Add!\n");
        exit(1);
    }
    tmp->kind = is_Add;
    return tmp;
}

/********************   Sub    ********************/

Binop make_Sub()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Sub!\n");
        exit(1);
    }
    tmp->kind = is_Sub;
    return tmp;
}

/********************   Mul    ********************/

Binop make_Mul()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Mul!\n");
        exit(1);
    }
    tmp->kind = is_Mul;
    return tmp;
}

/********************   Div    ********************/

Binop make_Div()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Div!\n");
        exit(1);
    }
    tmp->kind = is_Div;
    return tmp;
}

/********************   Lte    ********************/

Binop make_Lte()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Lte!\n");
        exit(1);
    }
    tmp->kind = is_Lte;
    return tmp;
}

/********************   Eq    ********************/

Binop make_Eq()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Eq!\n");
        exit(1);
    }
    tmp->kind = is_Eq;
    return tmp;
}

/********************   Neq    ********************/

Binop make_Neq()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Neq!\n");
        exit(1);
    }
    tmp->kind = is_Neq;
    return tmp;
}

/********************   Gte    ********************/

Binop make_Gte()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Gte!\n");
        exit(1);
    }
    tmp->kind = is_Gte;
    return tmp;
}

/********************   Lt    ********************/

Binop make_Lt()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Lt!\n");
        exit(1);
    }
    tmp->kind = is_Lt;
    return tmp;
}

/********************   Gt    ********************/

Binop make_Gt()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Gt!\n");
        exit(1);
    }
    tmp->kind = is_Gt;
    return tmp;
}

/********************   And    ********************/

Binop make_And()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating And!\n");
        exit(1);
    }
    tmp->kind = is_And;
    return tmp;
}

/********************   Or    ********************/

Binop make_Or()
{
    Binop tmp = (Binop) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Or!\n");
        exit(1);
    }
    tmp->kind = is_Or;
    return tmp;
}

/********************   BCons    ********************/

Block make_BCons(State p1, Block p2)
{
    Block tmp = (Block) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BCons!\n");
        exit(1);
    }
    tmp->kind = is_BCons;
    tmp->u.bCons_.state_ = p1;
    tmp->u.bCons_.block_ = p2;
    return tmp;
}

/********************   BNil    ********************/

Block make_BNil()
{
    Block tmp = (Block) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating BNil!\n");
        exit(1);
    }
    tmp->kind = is_BNil;
    return tmp;
}

/********************   SAssn    ********************/

State make_SAssn(Ident p1, Expr p2)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SAssn!\n");
        exit(1);
    }
    tmp->kind = is_SAssn;
    tmp->u.sAssn_.ident_ = p1;
    tmp->u.sAssn_.expr_ = p2;
    return tmp;
}

/********************   SPrint    ********************/

State make_SPrint(Expr p1)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SPrint!\n");
        exit(1);
    }
    tmp->kind = is_SPrint;
    tmp->u.sPrint_.expr_ = p1;
    return tmp;
}

/********************   SIf    ********************/

State make_SIf(Expr p1, Block p2)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SIf!\n");
        exit(1);
    }
    tmp->kind = is_SIf;
    tmp->u.sIf_.expr_ = p1;
    tmp->u.sIf_.block_ = p2;
    return tmp;
}

/********************   SIfEl    ********************/

State make_SIfEl(Expr p1, Block p2, Block p3)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SIfEl!\n");
        exit(1);
    }
    tmp->kind = is_SIfEl;
    tmp->u.sIfEl_.expr_ = p1;
    tmp->u.sIfEl_.block_1 = p2;
    tmp->u.sIfEl_.block_2 = p3;
    return tmp;
}

/********************   SWhile    ********************/

State make_SWhile(Expr p1, Block p2)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SWhile!\n");
        exit(1);
    }
    tmp->kind = is_SWhile;
    tmp->u.sWhile_.expr_ = p1;
    tmp->u.sWhile_.block_ = p2;
    return tmp;
}

/********************   SExpr    ********************/

State make_SExpr(Expr p1)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SExpr!\n");
        exit(1);
    }
    tmp->kind = is_SExpr;
    tmp->u.sExpr_.expr_ = p1;
    return tmp;
}

/********************   SRet    ********************/

State make_SRet(Expr p1)
{
    State tmp = (State) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SRet!\n");
        exit(1);
    }
    tmp->kind = is_SRet;
    tmp->u.sRet_.expr_ = p1;
    return tmp;
}

/********************   FDecl    ********************/

FunDecl make_FDecl(Ident p1, Args p2, Block p3)
{
    FunDecl tmp = (FunDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FDecl!\n");
        exit(1);
    }
    tmp->kind = is_FDecl;
    tmp->u.fDecl_.ident_ = p1;
    tmp->u.fDecl_.args_ = p2;
    tmp->u.fDecl_.block_ = p3;
    return tmp;
}

/********************   AArgs    ********************/

Args make_AArgs(Ident p1, ArgsRest p2)
{
    Args tmp = (Args) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating AArgs!\n");
        exit(1);
    }
    tmp->kind = is_AArgs;
    tmp->u.aArgs_.ident_ = p1;
    tmp->u.aArgs_.argsrest_ = p2;
    return tmp;
}

/********************   ANone    ********************/

Args make_ANone()
{
    Args tmp = (Args) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ANone!\n");
        exit(1);
    }
    tmp->kind = is_ANone;
    return tmp;
}

/********************   ACons    ********************/

ArgsRest make_ACons(Ident p1, ArgsRest p2)
{
    ArgsRest tmp = (ArgsRest) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ACons!\n");
        exit(1);
    }
    tmp->kind = is_ACons;
    tmp->u.aCons_.ident_ = p1;
    tmp->u.aCons_.argsrest_ = p2;
    return tmp;
}

/********************   ANil    ********************/

ArgsRest make_ANil()
{
    ArgsRest tmp = (ArgsRest) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ANil!\n");
        exit(1);
    }
    tmp->kind = is_ANil;
    return tmp;
}

/********************   FAArgs    ********************/

FArgs make_FAArgs(Expr p1, FArgsRest p2)
{
    FArgs tmp = (FArgs) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FAArgs!\n");
        exit(1);
    }
    tmp->kind = is_FAArgs;
    tmp->u.fAArgs_.expr_ = p1;
    tmp->u.fAArgs_.fargsrest_ = p2;
    return tmp;
}

/********************   FANone    ********************/

FArgs make_FANone()
{
    FArgs tmp = (FArgs) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FANone!\n");
        exit(1);
    }
    tmp->kind = is_FANone;
    return tmp;
}

/********************   FACons    ********************/

FArgsRest make_FACons(Expr p1, FArgsRest p2)
{
    FArgsRest tmp = (FArgsRest) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FACons!\n");
        exit(1);
    }
    tmp->kind = is_FACons;
    tmp->u.fACons_.expr_ = p1;
    tmp->u.fACons_.fargsrest_ = p2;
    return tmp;
}

/********************   FANil    ********************/

FArgsRest make_FANil()
{
    FArgsRest tmp = (FArgsRest) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FANil!\n");
        exit(1);
    }
    tmp->kind = is_FANil;
    return tmp;
}

/***************************   Cloning   ******************************/

TopLevel clone_TopLevel(TopLevel p)
{
  switch(p->kind)
  {
  case is_TLCons:
    return make_TLCons
      ( clone_FunDecl(p->u.tLCons_.fundecl_)
      , clone_TopLevel(p->u.tLCons_.toplevel_)
      );

  case is_TLNil:
    return make_TLNil ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning TopLevel!\n");
    exit(1);
  }
}

Expr clone_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_EVar:
    return make_EVar (strdup(p->u.eVar_.ident_));

  case is_ETrue:
    return make_ETrue ();

  case is_EFalse:
    return make_EFalse ();

  case is_EInt:
    return make_EInt (p->u.eInt_.integer_);

  case is_EBinOp:
    return make_EBinOp
      ( clone_Expr(p->u.eBinOp_.expr_1)
      , clone_Binop(p->u.eBinOp_.binop_)
      , clone_Expr(p->u.eBinOp_.expr_2)
      );

  case is_EFnCall:
    return make_EFnCall
      ( strdup(p->u.eFnCall_.ident_)
      , clone_FArgs(p->u.eFnCall_.fargs_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Expr!\n");
    exit(1);
  }
}

Binop clone_Binop(Binop p)
{
  switch(p->kind)
  {
  case is_Add:
    return make_Add ();

  case is_Sub:
    return make_Sub ();

  case is_Mul:
    return make_Mul ();

  case is_Div:
    return make_Div ();

  case is_Lte:
    return make_Lte ();

  case is_Eq:
    return make_Eq ();

  case is_Neq:
    return make_Neq ();

  case is_Gte:
    return make_Gte ();

  case is_Lt:
    return make_Lt ();

  case is_Gt:
    return make_Gt ();

  case is_And:
    return make_And ();

  case is_Or:
    return make_Or ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Binop!\n");
    exit(1);
  }
}

Block clone_Block(Block p)
{
  switch(p->kind)
  {
  case is_BCons:
    return make_BCons
      ( clone_State(p->u.bCons_.state_)
      , clone_Block(p->u.bCons_.block_)
      );

  case is_BNil:
    return make_BNil ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Block!\n");
    exit(1);
  }
}

State clone_State(State p)
{
  switch(p->kind)
  {
  case is_SAssn:
    return make_SAssn
      ( strdup(p->u.sAssn_.ident_)
      , clone_Expr(p->u.sAssn_.expr_)
      );

  case is_SPrint:
    return make_SPrint (clone_Expr(p->u.sPrint_.expr_));

  case is_SIf:
    return make_SIf
      ( clone_Expr(p->u.sIf_.expr_)
      , clone_Block(p->u.sIf_.block_)
      );

  case is_SIfEl:
    return make_SIfEl
      ( clone_Expr(p->u.sIfEl_.expr_)
      , clone_Block(p->u.sIfEl_.block_1)
      , clone_Block(p->u.sIfEl_.block_2)
      );

  case is_SWhile:
    return make_SWhile
      ( clone_Expr(p->u.sWhile_.expr_)
      , clone_Block(p->u.sWhile_.block_)
      );

  case is_SExpr:
    return make_SExpr (clone_Expr(p->u.sExpr_.expr_));

  case is_SRet:
    return make_SRet (clone_Expr(p->u.sRet_.expr_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning State!\n");
    exit(1);
  }
}

FunDecl clone_FunDecl(FunDecl p)
{
  switch(p->kind)
  {
  case is_FDecl:
    return make_FDecl
      ( strdup(p->u.fDecl_.ident_)
      , clone_Args(p->u.fDecl_.args_)
      , clone_Block(p->u.fDecl_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning FunDecl!\n");
    exit(1);
  }
}

Args clone_Args(Args p)
{
  switch(p->kind)
  {
  case is_AArgs:
    return make_AArgs
      ( strdup(p->u.aArgs_.ident_)
      , clone_ArgsRest(p->u.aArgs_.argsrest_)
      );

  case is_ANone:
    return make_ANone ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Args!\n");
    exit(1);
  }
}

ArgsRest clone_ArgsRest(ArgsRest p)
{
  switch(p->kind)
  {
  case is_ACons:
    return make_ACons
      ( strdup(p->u.aCons_.ident_)
      , clone_ArgsRest(p->u.aCons_.argsrest_)
      );

  case is_ANil:
    return make_ANil ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning ArgsRest!\n");
    exit(1);
  }
}

FArgs clone_FArgs(FArgs p)
{
  switch(p->kind)
  {
  case is_FAArgs:
    return make_FAArgs
      ( clone_Expr(p->u.fAArgs_.expr_)
      , clone_FArgsRest(p->u.fAArgs_.fargsrest_)
      );

  case is_FANone:
    return make_FANone ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning FArgs!\n");
    exit(1);
  }
}

FArgsRest clone_FArgsRest(FArgsRest p)
{
  switch(p->kind)
  {
  case is_FACons:
    return make_FACons
      ( clone_Expr(p->u.fACons_.expr_)
      , clone_FArgsRest(p->u.fACons_.fargsrest_)
      );

  case is_FANil:
    return make_FANil ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning FArgsRest!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_TopLevel(TopLevel p)
{
  switch(p->kind)
  {
  case is_TLCons:
    free_FunDecl(p->u.tLCons_.fundecl_);
    free_TopLevel(p->u.tLCons_.toplevel_);
    break;

  case is_TLNil:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TopLevel!\n");
    exit(1);
  }
  free(p);
}

void free_Expr(Expr p)
{
  switch(p->kind)
  {
  case is_EVar:
    free(p->u.eVar_.ident_);
    break;

  case is_ETrue:
    break;

  case is_EFalse:
    break;

  case is_EInt:
    break;

  case is_EBinOp:
    free_Expr(p->u.eBinOp_.expr_1);
    free_Binop(p->u.eBinOp_.binop_);
    free_Expr(p->u.eBinOp_.expr_2);
    break;

  case is_EFnCall:
    free(p->u.eFnCall_.ident_);
    free_FArgs(p->u.eFnCall_.fargs_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Expr!\n");
    exit(1);
  }
  free(p);
}

void free_Binop(Binop p)
{
  switch(p->kind)
  {
  case is_Add:
    break;

  case is_Sub:
    break;

  case is_Mul:
    break;

  case is_Div:
    break;

  case is_Lte:
    break;

  case is_Eq:
    break;

  case is_Neq:
    break;

  case is_Gte:
    break;

  case is_Lt:
    break;

  case is_Gt:
    break;

  case is_And:
    break;

  case is_Or:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Binop!\n");
    exit(1);
  }
  free(p);
}

void free_Block(Block p)
{
  switch(p->kind)
  {
  case is_BCons:
    free_State(p->u.bCons_.state_);
    free_Block(p->u.bCons_.block_);
    break;

  case is_BNil:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Block!\n");
    exit(1);
  }
  free(p);
}

void free_State(State p)
{
  switch(p->kind)
  {
  case is_SAssn:
    free(p->u.sAssn_.ident_);
    free_Expr(p->u.sAssn_.expr_);
    break;

  case is_SPrint:
    free_Expr(p->u.sPrint_.expr_);
    break;

  case is_SIf:
    free_Expr(p->u.sIf_.expr_);
    free_Block(p->u.sIf_.block_);
    break;

  case is_SIfEl:
    free_Expr(p->u.sIfEl_.expr_);
    free_Block(p->u.sIfEl_.block_1);
    free_Block(p->u.sIfEl_.block_2);
    break;

  case is_SWhile:
    free_Expr(p->u.sWhile_.expr_);
    free_Block(p->u.sWhile_.block_);
    break;

  case is_SExpr:
    free_Expr(p->u.sExpr_.expr_);
    break;

  case is_SRet:
    free_Expr(p->u.sRet_.expr_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing State!\n");
    exit(1);
  }
  free(p);
}

void free_FunDecl(FunDecl p)
{
  switch(p->kind)
  {
  case is_FDecl:
    free(p->u.fDecl_.ident_);
    free_Args(p->u.fDecl_.args_);
    free_Block(p->u.fDecl_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FunDecl!\n");
    exit(1);
  }
  free(p);
}

void free_Args(Args p)
{
  switch(p->kind)
  {
  case is_AArgs:
    free(p->u.aArgs_.ident_);
    free_ArgsRest(p->u.aArgs_.argsrest_);
    break;

  case is_ANone:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Args!\n");
    exit(1);
  }
  free(p);
}

void free_ArgsRest(ArgsRest p)
{
  switch(p->kind)
  {
  case is_ACons:
    free(p->u.aCons_.ident_);
    free_ArgsRest(p->u.aCons_.argsrest_);
    break;

  case is_ANil:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ArgsRest!\n");
    exit(1);
  }
  free(p);
}

void free_FArgs(FArgs p)
{
  switch(p->kind)
  {
  case is_FAArgs:
    free_Expr(p->u.fAArgs_.expr_);
    free_FArgsRest(p->u.fAArgs_.fargsrest_);
    break;

  case is_FANone:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FArgs!\n");
    exit(1);
  }
  free(p);
}

void free_FArgsRest(FArgsRest p)
{
  switch(p->kind)
  {
  case is_FACons:
    free_Expr(p->u.fACons_.expr_);
    free_FArgsRest(p->u.fACons_.fargsrest_);
    break;

  case is_FANil:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FArgsRest!\n");
    exit(1);
  }
  free(p);
}

