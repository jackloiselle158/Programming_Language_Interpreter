/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct TopLevel_;
typedef struct TopLevel_ *TopLevel;

struct Expr_;
typedef struct Expr_ *Expr;

struct Binop_;
typedef struct Binop_ *Binop;

struct Block_;
typedef struct Block_ *Block;

struct State_;
typedef struct State_ *State;

struct FunDecl_;
typedef struct FunDecl_ *FunDecl;

struct Args_;
typedef struct Args_ *Args;

struct ArgsRest_;
typedef struct ArgsRest_ *ArgsRest;

struct FArgs_;
typedef struct FArgs_ *FArgs;

struct FArgsRest_;
typedef struct FArgsRest_ *FArgsRest;

/********************   Abstract Syntax Classes    ********************/

struct TopLevel_
{
  enum { is_TLCons, is_TLNil } kind;
  union
  {
    struct { FunDecl fundecl_; TopLevel toplevel_; } tLCons_;
  } u;
};

TopLevel make_TLCons(FunDecl p0, TopLevel p1);
TopLevel make_TLNil(void);

struct Expr_
{
  enum { is_EVar, is_ETrue, is_EFalse, is_EInt, is_EBinOp, is_EFnCall } kind;
  union
  {
    struct { Ident ident_; } eVar_;
    struct { Integer integer_; } eInt_;
    struct { Binop binop_; Expr expr_1, expr_2; } eBinOp_;
    struct { FArgs fargs_; Ident ident_; } eFnCall_;
  } u;
};

Expr make_EVar(Ident p0);
Expr make_ETrue(void);
Expr make_EFalse(void);
Expr make_EInt(Integer p0);
Expr make_EBinOp(Expr p0, Binop p1, Expr p2);
Expr make_EFnCall(Ident p0, FArgs p1);

struct Binop_
{
  enum { is_Add, is_Sub, is_Mul, is_Div, is_Lte, is_Eq, is_Neq, is_Gte, is_Lt, is_Gt, is_And, is_Or } kind;
  union
  {
  } u;
};

Binop make_Add(void);
Binop make_Sub(void);
Binop make_Mul(void);
Binop make_Div(void);
Binop make_Lte(void);
Binop make_Eq(void);
Binop make_Neq(void);
Binop make_Gte(void);
Binop make_Lt(void);
Binop make_Gt(void);
Binop make_And(void);
Binop make_Or(void);

struct Block_
{
  enum { is_BCons, is_BNil } kind;
  union
  {
    struct { Block block_; State state_; } bCons_;
  } u;
};

Block make_BCons(State p0, Block p1);
Block make_BNil(void);

struct State_
{
  enum { is_SAssn, is_SPrint, is_SIf, is_SIfEl, is_SWhile, is_SExpr, is_SRet } kind;
  union
  {
    struct { Expr expr_; Ident ident_; } sAssn_;
    struct { Expr expr_; } sPrint_;
    struct { Block block_; Expr expr_; } sIf_;
    struct { Block block_1, block_2; Expr expr_; } sIfEl_;
    struct { Block block_; Expr expr_; } sWhile_;
    struct { Expr expr_; } sExpr_;
    struct { Expr expr_; } sRet_;
  } u;
};

State make_SAssn(Ident p0, Expr p1);
State make_SPrint(Expr p0);
State make_SIf(Expr p0, Block p1);
State make_SIfEl(Expr p0, Block p1, Block p2);
State make_SWhile(Expr p0, Block p1);
State make_SExpr(Expr p0);
State make_SRet(Expr p0);

struct FunDecl_
{
  enum { is_FDecl } kind;
  union
  {
    struct { Args args_; Block block_; Ident ident_; } fDecl_;
  } u;
};

FunDecl make_FDecl(Ident p0, Args p1, Block p2);

struct Args_
{
  enum { is_AArgs, is_ANone } kind;
  union
  {
    struct { ArgsRest argsrest_; Ident ident_; } aArgs_;
  } u;
};

Args make_AArgs(Ident p0, ArgsRest p1);
Args make_ANone(void);

struct ArgsRest_
{
  enum { is_ACons, is_ANil } kind;
  union
  {
    struct { ArgsRest argsrest_; Ident ident_; } aCons_;
  } u;
};

ArgsRest make_ACons(Ident p0, ArgsRest p1);
ArgsRest make_ANil(void);

struct FArgs_
{
  enum { is_FAArgs, is_FANone } kind;
  union
  {
    struct { Expr expr_; FArgsRest fargsrest_; } fAArgs_;
  } u;
};

FArgs make_FAArgs(Expr p0, FArgsRest p1);
FArgs make_FANone(void);

struct FArgsRest_
{
  enum { is_FACons, is_FANil } kind;
  union
  {
    struct { Expr expr_; FArgsRest fargsrest_; } fACons_;
  } u;
};

FArgsRest make_FACons(Expr p0, FArgsRest p1);
FArgsRest make_FANil(void);

/***************************   Cloning   ******************************/

TopLevel clone_TopLevel(TopLevel p);
Expr clone_Expr(Expr p);
Binop clone_Binop(Binop p);
Block clone_Block(Block p);
State clone_State(State p);
FunDecl clone_FunDecl(FunDecl p);
Args clone_Args(Args p);
ArgsRest clone_ArgsRest(ArgsRest p);
FArgs clone_FArgs(FArgs p);
FArgsRest clone_FArgsRest(FArgsRest p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_TopLevel(TopLevel p);
void free_Expr(Expr p);
void free_Binop(Binop p);
void free_Block(Block p);
void free_State(State p);
void free_FunDecl(FunDecl p);
void free_Args(Args p);
void free_ArgsRest(ArgsRest p);
void free_FArgs(FArgs p);
void free_FArgsRest(FArgsRest p);


#endif
